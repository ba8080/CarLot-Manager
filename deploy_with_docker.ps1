# Car Lot Manager - Docker-based Deployment Script
# This script runs Terraform, Ansible, and Helm using Docker containers.
# No local tools required (except Docker).

$ErrorActionPreference = "Stop"
$PWD_PATH = Get-Location

Write-Host "üöÄ Starting Docker-based Deployment..." -ForegroundColor Green

# 1. Check for SSH Key
$KEY_FILE = "generated_key.pem"
Write-Host "‚ÑπÔ∏è  SSH Key will be generated by Terraform: $KEY_FILE" -ForegroundColor Cyan

# 2. Terraform
Write-Host "`nüèóÔ∏è  Running Terraform (Provisioning Infrastructure)..." -ForegroundColor Cyan
docker run --rm -v "$PWD_PATH/terraform:/workspace" -v "$PWD_PATH/aws_credentials:/aws_credentials" -w /workspace hashicorp/terraform:light init
docker run --rm -v "$PWD_PATH/terraform:/workspace" -v "$PWD_PATH/aws_credentials:/aws_credentials" -w /workspace hashicorp/terraform:light apply -auto-approve

# Get Outputs
$ALB_DNS = docker run --rm -v "$PWD_PATH/terraform:/workspace" -v "$PWD_PATH/aws_credentials:/aws_credentials" -w /workspace hashicorp/terraform:light output -raw alb_dns_name
$INSTANCE_IPS = docker run --rm -v "$PWD_PATH/terraform:/workspace" -v "$PWD_PATH/aws_credentials:/aws_credentials" -w /workspace hashicorp/terraform:light output -json instance_ips
Write-Host "‚úÖ Infrastructure Ready!" -ForegroundColor Green
Write-Host "ALB DNS: $ALB_DNS"
Write-Host "Instance IPs: $INSTANCE_IPS"

# 3. Ansible
Write-Host "`n‚öôÔ∏è  Running Ansible (Configuring Kubernetes)..." -ForegroundColor Cyan

# Create Inventory File
$IPS = $INSTANCE_IPS | ConvertFrom-Json
$INVENTORY_CONTENT = "[master]`n$($IPS[0]) ansible_user=ubuntu ansible_ssh_private_key_file=/key.pem ansible_ssh_common_args='-o StrictHostKeyChecking=no'`n`n[worker]`n"
for ($i = 1; $i -lt $IPS.Count; $i++) {
    $INVENTORY_CONTENT += "$($IPS[$i]) ansible_user=ubuntu ansible_ssh_private_key_file=/key.pem ansible_ssh_common_args='-o StrictHostKeyChecking=no'`n"
}
Set-Content -Path "ansible/inventory.ini" -Value $INVENTORY_CONTENT

# Run Ansible Container
# We mount the key file to /key.pem inside the container
docker run --rm -v "$PWD_PATH/ansible:/ansible" -v "$PWD_PATH/$KEY_FILE:/key.pem" -w /ansible cytopia/ansible playbook inventory.ini playbook.yml

Write-Host "‚úÖ Configuration Complete!" -ForegroundColor Green

# 4. Helm
Write-Host "`n‚öì Running Helm (Deploying Application)..." -ForegroundColor Cyan

# Fetch Kubeconfig from Master
$MASTER_IP = $IPS[0]
Write-Host "Fetching kubeconfig from Master ($MASTER_IP)..."
# We use a temporary container to scp the config
docker run --rm -v "$PWD_PATH:/data" -v "$PWD_PATH/$KEY_FILE:/key.pem" alpine sh -c "apk add openssh-client && scp -o StrictHostKeyChecking=no -i /key.pem ubuntu@$MASTER_IP:/home/ubuntu/.kube/config /data/kubeconfig"

# Replace internal IP with public IP in kubeconfig (if needed, though we are connecting to public IP)
# Actually, kubeadm init usually sets the internal IP in the cert. We might need to use --insecure-skip-tls-verify
# For simplicity, we'll try to use it as is, but we might need to edit the server IP in kubeconfig
(Get-Content kubeconfig) -replace "server: https://.*:6443", "server: https://$MASTER_IP:6443" | Set-Content kubeconfig

# Run Helm
docker run --rm -v "$PWD_PATH:/apps" -e KUBECONFIG=/apps/kubeconfig -w /apps alpine/helm:latest upgrade --install car-lot-manager ./helm/car-lot --set nfs.server=$MASTER_IP

Write-Host "`nüéâ Deployment Complete!" -ForegroundColor Green
Write-Host "Access your application at: http://$ALB_DNS"
