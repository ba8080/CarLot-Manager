name: DevOps Final Project Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: car-lot-manager
  DOCKER_IMAGE: azexkush/car-lot-manager

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

    - name: Run Unit Tests
      run: python -m unittest discover tests

    - name: Login to Docker Hub
      if: ${{ secrets.DOCKERHUB_USERNAME != '' && secrets.DOCKERHUB_TOKEN != '' }}
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push Docker image
      if: ${{ secrets.DOCKERHUB_USERNAME != '' && secrets.DOCKERHUB_TOKEN != '' }}
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: ${{ env.DOCKER_IMAGE }}:latest,${{ env.DOCKER_IMAGE }}:${{ github.sha }}

  provision-infrastructure:
    needs: test-and-build
    runs-on: ubuntu-latest
    outputs:
      alb_dns: ${{ steps.tf_output.outputs.alb_dns }}
    steps:
    - uses: actions/checkout@v3

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2

    - name: Terraform Init
      working-directory: ./terraform
      run: terraform init
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}

    - name: Terraform Apply
      working-directory: ./terraform
      id: tf_apply
      run: terraform apply -auto-approve
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}

    - name: Get Terraform Outputs
      id: tf_output
      working-directory: ./terraform
      run: |
        echo "alb_dns=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}

  configure-and-deploy:
    needs: provision-infrastructure
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_wrapper: false

    - name: Get Terraform Outputs
      working-directory: ./terraform
      run: |
        terraform init
        MASTER_IP=$(terraform output -json instance_ips | jq -r '.[0]')
        MASTER_PRIVATE_IP=$(terraform output -raw master_private_ip)
        WORKER1_IP=$(terraform output -json instance_ips | jq -r '.[1]')
        WORKER2_IP=$(terraform output -json instance_ips | jq -r '.[2]')
        ALB_DNS=$(terraform output -raw alb_dns_name)
        
        # Validate outputs
        if [ -z "$MASTER_IP" ] || [ "$MASTER_IP" == "null" ]; then
          echo "Error: MASTER_IP is empty"
          exit 1
        fi
        if [ -z "$WORKER1_IP" ] || [ "$WORKER1_IP" == "null" ]; then
          echo "Error: WORKER1_IP is empty"
          exit 1
        fi
        if [ -z "$WORKER2_IP" ] || [ "$WORKER2_IP" == "null" ]; then
          echo "Error: WORKER2_IP is empty"
          exit 1
        fi
        
        echo "MASTER_IP=$MASTER_IP" >> $GITHUB_ENV
        echo "MASTER_PRIVATE_IP=$MASTER_PRIVATE_IP" >> $GITHUB_ENV
        echo "WORKER1_IP=$WORKER1_IP" >> $GITHUB_ENV
        echo "WORKER2_IP=$WORKER2_IP" >> $GITHUB_ENV
        echo "ALB_DNS=$ALB_DNS" >> $GITHUB_ENV
        
        echo "Extracted IPs:"
        echo "Master: $MASTER_IP"
        echo "Worker1: $WORKER1_IP"
        echo "Worker2: $WORKER2_IP"
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}

    - name: Create Ansible Inventory
      run: |
        mkdir -p ansible
        cat > ansible/inventory.ini << 'EOF'
        [master]
        ${{ env.MASTER_IP }} ansible_user=ubuntu ansible_ssh_private_key_file=/tmp/key.pem ansible_ssh_common_args='-o StrictHostKeyChecking=no'

        [worker]
        ${{ env.WORKER1_IP }} ansible_user=ubuntu ansible_ssh_private_key_file=/tmp/key.pem ansible_ssh_common_args='-o StrictHostKeyChecking=no'
        ${{ env.WORKER2_IP }} ansible_user=ubuntu ansible_ssh_private_key_file=/tmp/key.pem ansible_ssh_common_args='-o StrictHostKeyChecking=no'

        [all:vars]
        ansible_python_interpreter=/usr/bin/python3
        EOF
        
        echo "Generated inventory.ini:"
        cat ansible/inventory.ini
        
        # Validate inventory file
        if ! grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' ansible/inventory.ini; then
          echo "Error: No valid IP addresses found in inventory file"
          exit 1
        fi

    - name: Extract SSH Key
      working-directory: ./terraform
      run: |
        terraform output -raw ssh_private_key > /tmp/key.pem
        chmod 600 /tmp/key.pem
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}

    - name: Wait for Instances to be Ready
      run: |
        echo "Waiting for SSH to be available..."
        for ip in ${{ env.MASTER_IP }} ${{ env.WORKER1_IP }} ${{ env.WORKER2_IP }}; do
          for i in {1..30}; do
            if ssh -i /tmp/key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=5 ubuntu@$ip exit 2>/dev/null; then
              echo "SSH ready on $ip"
              break
            fi
            echo "Waiting for $ip... ($i/30)"
            sleep 10
          done
        done

    - name: Install Ansible
      run: sudo apt-get update && sudo apt-get install -y ansible

    - name: Run Ansible Playbook
      run: ansible-playbook -i ansible/inventory.ini ansible/playbook.yml
      env:
        ANSIBLE_HOST_KEY_CHECKING: 'False'

    - name: Fetch Kubeconfig
      run: |
        scp -i /tmp/key.pem -o StrictHostKeyChecking=no ubuntu@${{ env.MASTER_IP }}:/home/ubuntu/.kube/config /tmp/kubeconfig
        sed -i "s/server: https:\/\/.*:6443/server: https:\/\/${{ env.MASTER_IP }}:6443/" /tmp/kubeconfig

    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: v3.11.1

    - name: Deploy with Helm
      run: |
        export KUBECONFIG=/tmp/kubeconfig
        helm upgrade --install car-lot-manager ./helm/car-lot \
          --set nfs.server=${{ env.MASTER_PRIVATE_IP }} \
          --wait --timeout 10m

    - name: Deployment Complete
      run: |
        echo "ðŸŽ‰ Deployment Successful!"
        echo "Access your application at: http://${{ env.ALB_DNS }}"

